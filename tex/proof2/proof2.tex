\documentclass [a4paper,11pt]{scrartcl}
\usepackage{minted}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{fullpage,paralist}

\usepackage{listings,multicol}
\lstset{basicstyle=\ttfamily}
\usepackage [scaled=0.8]{DejaVuSansMono} % decent mono font
\usepackage{enumitem}
\setitemize{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}
\setenumerate{noitemsep,topsep=3pt,parsep=3pt,partopsep=3pt}

\usepackage{amsmath} % align*
\usepackage{amssymb} % mathbb
\usepackage{mathrsfs}  % mathscr
\usepackage{amsthm}
\usepackage{amsfonts}

\usepackage{mathpartir}
\def \RightTirNameStyle{\textnormal}

\usepackage [bookmarks,colorlinks=true,citecolor=red]{hyperref}
\usepackage [noabbrev,capitalize]{cleveref}

\newtheorem{definition}{Définition}[subsection]
\newtheorem{lemme}{Lemme}[subsection]
\newtheorem{theorem}{Theorem}[subsection]

%============================================================

\title{
  Recherche de fonctions par types \\[0.5em]
  \large Un peu de théorie
}
\date{}

%============================================================

\newcommand{\interval}[2]{[\![#1\,;#2]\!]}

\newcommand{\ssi}{\textit{ssi}}

\newcommand{\Var}{{\cal V}}
\newcommand{\Constr}{{\cal C}}
\newcommand{\tconstr}{\texttt{t}}
\newcommand{\C}{{\cal C}}
\newcommand{\T}{{\cal T}}
\newcommand{\N}{{\cal N}}
\newcommand{\MSet}{{\cal M}}

\newcommand\tprod{\times}
\newcommand\tlist{\overline}
\newcommand\tmset[1]{\{\overline{#1}\}}

\newcommand{\qeq}{\stackrel ? =}
\newcommand{\Eeq}{\stackrel \E =}
\newcommand{\ueq}{\stackrel u =}

%============================================================
%============================================================

\begin{document}

\maketitle

%============================================================
%============================================================

\section{Types}

\subsection{Preliminaries and notations}

We consider $\Var$ an infinite set of variables, which we often note $\alpha$, $\beta$, \dots.
We consider $\Constr$ the set of type constructors, which we often note as $\tconstr$.
We will note lists using either the in-extanso syntax $(x_0,\dots,x_n)$ or the
bared notation $\tlist{x}$.


\subsection{Grammar}

We define $\T$ the set of types defined inductively
as follow:
\begin{align*}
  \tau \in \T
  =& \texttt{unit}\\
  |& \Var\\
  |& (\tlist\tau) \tconstr\\
  |& \tau \tprod \tau\\
  |& \tau \to \tau  
\end{align*}

\subsection{Equivalence}

\newcommand\eqT{=^{\T}_{ISO}}

We say that $\tau$ is equivalent with $\tau'$ modulo isomorphism,
noted $\tau \eqT \tau'$. We define
equivalence as the smallest congruence which is transitive, reflexive, symmetric and respect the following axioms:

\begin{itemize}
\item Associativity of $\tprod$ : $x \tprod (y \tprod z) \eqT (x \tprod y) \tprod z$
\item Commutativity of $\tprod$ : $x \tprod y \eqT y \tprod x$
\item Neutrality of \texttt{unit} for $\tprod$ : $\texttt{unit} \tprod x \eqT x$ 
\item Currification : $(x \tprod y) \to z \eqT x \to y \to z$
\end{itemize}


\subsection{Unification}

\newcommand\unifT{\equiv^{\T}_{ISO}}

We say that $\tau$ unifies with $\tau'$ modulo isomorphism, noted $\tau \unifT \tau'$, if there exists $\sigma$ a substitution $\Var \to \T$ such that $\sigma\tau \eqT \sigma\tau'$.

\section{Normal forms}

\newcommand\eqAC{=_{AC}}
\newcommand\nf[1]{\texttt{NF}(#1)}

We consider tuples as multisets $m \in \MSet$, noted $\{\dots\}$,
which are sets where repeated entries can appear.
We note $\eqAC$ the equality over multisets, where exactly
the same number of entries must appear but the order of the entries doesn't matter.
We note $\cup$ the union of multisets (which preserve the repeated entries).

We define $\N$, the set of normalized types defined
inductively as follows:
\begin{align*}
  \tau \in \N
  =& \Var\\
  |& (\tlist\tau) \tconstr\\
  |& \tmset\tau\\
  |& \tmset\tau \to \tau
\end{align*}

We define $\cup$ on types as the tuple union that can flatten
nested tuples. It is defined as follow:
\begin{align*}
  \tmset{\tau_1} \cup \tmset{\tau_2} &= \{\tlist{\tau_1},\tlist{\tau_2}\}&
  \tmset{\tau_1} \cup \tau_2 &= \{\tlist{\tau_1},\tau_2\}\\
  \tau_1 \cup \tmset{\tau_2} &= \{\tau_1,\tlist{\tau_2}\}&
  \tau_1 \cup \tau_2 &= \{\tau_1,\tau_2\}
\end{align*}


We define the normalize on types, noted $\nf\tau$, as follow:
\begin{align*}
  \nf{\tau \tprod \tau'}
  &= \nf\tau \cup \nf{\tau'}\\
  \nf{\texttt{unit}} &= \{\}\\
  \nf{\tau \to \tau'}
  &= \begin{cases}
    (\nf\tau \cup \tmset{\tau_{args}}) \to \tau_{res} & \text{when $\nf\tau' = \tmset{\tau_{args}} \to \tau_{res}$}\\
    \nf\tau \to \nf{\tau'} & \text{otherwise}    
  \end{cases} \\
  \nf{\alpha} &= \alpha \qquad\text{for }\alpha\in\Var\\
  \nf{(\tlist\tau)\ \tconstr} &= (\tlist{\nf\tau})\ \tconstr  
\end{align*}



\subsection{Equivalence}

\newcommand\eqN{=^{\N}_{ISO}}
\newcommand\unifN{\equiv^{\N}_{ISO}}

We say that $\tau$ is equivalent with $\tau'$ modulo isomorphism, noted $\tau \eqN \tau'$. We define
equivalence as the smallest congruence which is transitive, reflexive, symmetric and respects the following axioms:


\begin{itemize}
\item AC of tuples : $\tmset{x} \eqN \tmset{y}$ iff $\tmset{x} \eqAC \tmset{y}$.
\item Neutrality of \texttt{unit} : $\{x\} \eqN x$ 
\item Currification : $\{\tlist{x},\tlist{y}\} \to z \eqN \tmset{x} \to (\tmset{y} \to z)$
\end{itemize}

\subsection{Normalization preserves equivalence}

\begin{theorem}
For all type $\tau$ and $\tau'$, the two type are equivalent modulo isomorphisms, $\tau \eqT \tau'$ if and only if their normal forms are equivalent modulo isomorphisms $\nf{\tau} \eqN \nf{\tau'}$.

\begin{proof}
We proceed by inductions over the proof tree of $\tau \eqT \tau'$.
The only cases that differs between the two definitions
are the base cases over products and arrows.

\paragraph{Case Associativity}
We consider $\tau = x \tprod (y \tprod z)$ and $\tau' = (x \tprod y) \tprod z$.\\
We have $\nf{\tau} = \nf{x} \cup (\nf{y} \cup \nf{z})$ and $\nf{\tau'} = (\nf{x} \cup \nf{y}) \cup \nf{z}$.\\
By definition of $\cup$ and by associativity of $\eqAC$ on multisets,\\
$\tau \eqT \tau'$ if and only if $\nf{\tau} \eqN \nf{\tau'}$.

\paragraph{Case Commutativity}
We consider $\tau = x \tprod y$ and $\tau' = y \tprod x$.\\
We have $\nf{\tau} = \nf{x} \cup \nf{y}$ and $\nf{\tau'} = \nf{y} \cup \nf{x}$.\\
By definition of $\cup$ and by commutativity of $\eqAC$ on multisets,\\
$\tau \eqT \tau'$ if and only if $\nf{\tau} \eqN \nf{\tau'}$.

\paragraph{Case Neutrality}
We consider $\tau = \texttt{unit} \tprod x$ and $\tau' = x$.\\
We have $\nf{\tau} = \nf{\texttt{unit}} \cup \nf{x} = \nf{x}$ and $\nf{\tau'} = \nf{x}$.\\
$\tau \eqT \tau'$ if and only if $\nf{\tau} \eqN \nf{\tau'}$.

\paragraph{Case Curryfication}
We consider $\tau = (x \tprod y) \to z$ and $\tau' = x \to (y \to z)$.

\begin{itemize}
\item
  If $\nf{z}$ is not an arrow, we have:
  \begin{align*}
    \nf{\tau} &= \nf{(x \tprod y) \to z} = (\nf{x} \cup \nf{y}) \to \nf{z}\\
    \nf{\tau'} &= (\nf{x} \cup \nf{y}) \to \nf{z}
  \end{align*}
  $\tau \eqT \tau'$ if and only if $\nf{\tau} \eqN \nf{\tau'}$.
\item
  If $\nf{z} = \tmset{z_{args}} \to z_{res}$, we have:
  \begin{align*}
    \nf{\tau} &= \nf{(x \tprod y) \to z} = (\nf{x} \cup \nf{y} \cup \tmset{z_{args}}) \to z_{res}\\
    \nf{\tau'} &= (\nf{x} \cup \nf{y} \cup \tmset{z_{args}}) \to z_{res}
  \end{align*}
  $\tau \eqT \tau'$ if and only if $\nf{\tau} \eqN \nf{\tau'}$.
\end{itemize}


\paragraph{Case Congruence of $\tprod$}
All other cases are simply done by induction on the proof tree. We only detail
one case: the case of congruence over $\tprod$.
We have $\tau = \tau_1 \tprod \tau_2$ and $\tau' = \tau'_1 \tprod \tau'_2$
\begin{mathpar}
  \inferrule
  {\tau_1 \eqT \tau_1' \\ \tau_2 \eqT \tau_2'}
  {\tau_1 * \tau_2 \eqT \tau_1' * \tau_2'}
\end{mathpar}

By definition $\nf{\tau} = \nf{\tau_1} \cup \nf{\tau_2}$ must be a tuple. We
note it $\{\tlist{m_1},\tlist{m_2}\}$ with $\tlist{m_i}$ the contribution
of $\tau_i$ to the multiset.
We note similarly $\nf{\tau'} = \{\tlist{m'_1},\tlist{m'_2}\}$.

By induction, we have $\nf{\tau_1} \eqN \nf{\tau_1'}$ and
$\nf{\tau_2} \eqN \nf{\tau_2'}$, which gives us that
$\tmset{m_1} \eqN \tmset{m'_1}$ and $\tmset{m_2} \eqN \tmset{m'_2}$ (either the results of normalization are tuples, in which case it is immediate, or they are not, and then we work on singletons).

which is equivalent to the congruence rule on tuples:
\begin{mathpar}
  \inferrule
  {\tmset{m_1} \eqN \tmset{m'_1} \\ \tmset{m_2} \eqN \tmset{m'_2}}
  {\{\tlist{m_1},\tlist{m_2}\} \eqN \{\tlist{m'_1},\tlist{m'_2}\}}
\end{mathpar}


\end{proof}
\end{theorem}

\section{Features}

\newcommand\F{\cal F}

A \emph{feature} is a view of a datatype over which we have a fast test
that allow us to eliminate a candidate for unification.

\begin{definition}[Feature]
Let us consider $\F$ a set, $C_{\F}$ a function from $\N \to \F$ and $\leq_{\F}$ a relation over $\F$, we say that the triplet $(\F,C_{\F},\leq_{\F})$ is a \emph{feature} if it respects the following conditions:
\begin{itemize}
\item $\leq_{\F}$ is a total order on $\F$
\item For all types in normal form $\tau,\tau'\in\N$, $\tau \unifN \tau' \implies C_{\F}(\tau) \leq_{\F} C_{\F}(\tau')$.
\end{itemize}
\end{definition}

By contraposition, if $C_{\F}(\tau) \nleq_{\F} C_{\F}(\tau')$, then
$\tau$ and $\tau'$ can never unify. If the test $\leq_{\F}$ is fast, we can cheaply
avoid having to try unifying the types.

\subsection{By head}


\subsection{By Spine}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
