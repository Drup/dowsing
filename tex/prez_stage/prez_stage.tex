\documentclass[serif]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

%============================================================

%\usepackage{tabularx}
\usepackage{xspace}

%============================================================

\usepackage{amsmath}	% align*
\usepackage{amssymb}	% mathbb
\usepackage{mathrsfs}	% mathscr
\usepackage{scalerel}	% scalerel
\usepackage{mathtools}	% mathclap

%============================================================

\usepackage{mathpartir}
\def\RightTirNameStyle{\textnormal}

%============================================================

\newcommand{\dowsindex}{\texttt{dowsindex}\xspace}

\newcommand{\interval}[2]{[\![#1\,;#2]\!]}
\newcommand{\mset}[1]{\{\![#1]\!\}}

\newcommand{\qeq}{\stackrel {\scriptscriptstyle ?} =}

\newcommand{\ssi}{\textit{ssi}\xspace}
\newcommand{\unit}{\bold{unit}}
\newcommand{\norm}{\mathrm{norm}}

\newcommand{\V}{\mathscr{V}}
\newcommand{\F}{\mathscr{F}}
\newcommand{\E}{\mathscr{E}}
\newcommand{\G}{\mathscr{G}}
\newcommand{\T}{\mathrm{T}}
\newcommand{\N}{\mathrm{N}}

\newcommand{\mathhyphen}{{\hbox{-}}}

\DeclareMathOperator*{\msetN_bigplus}{\scalerel*{+}{\sum}^\#_\N}
\DeclareMathOperator*{\msetG_bigplus}{\scalerel*{+}{\sum}^\#_\G}

%============================================================

\title{Recherche de fonctions \\ par \\ unification modulo isomorphismes de types}
\author{Clément ALLAIN \\ Stage de M1 encadré par Gabriel RADANNE}
\date{\today}

%============================================================

\begin{document}

%============================================================

\begin{frame}
	\titlepage
\end{frame}

%============================================================

\begin{frame}
	\footnotesize
	\begin{table}[h]
		\centering
		\begin{tabular}{|l|l|l|}
			\hline
				Langage &
				Nom &
				Type
			\\
			\hline
				LCF ML &
				\texttt{itlist} &
				$(\alpha \rightarrow \beta \rightarrow \beta) \rightarrow list (\alpha) \rightarrow \beta \rightarrow \beta$
			\\
				Caml Light &
				\texttt{list\_it} &
				$(\alpha \rightarrow \beta \rightarrow \beta) \rightarrow list (\alpha) \rightarrow \beta \rightarrow \beta$
			\\
				Haskell &
				\texttt{foldr} &
				$(\alpha \rightarrow \beta \rightarrow \alpha) \rightarrow \alpha \rightarrow list (\beta) \rightarrow \alpha$
			\\
				SML of New Jersey &
				\texttt{fold} &
				$(\alpha \times \beta \rightarrow \beta) \rightarrow list (\alpha) \rightarrow \beta \rightarrow \beta$
			\\
				Edinburgh SML &
				\texttt{fold\_right} &
				$(\alpha \times \beta \rightarrow \beta) \rightarrow \beta \rightarrow list (\alpha) \rightarrow \beta$
			\\
			\hline
		\end{tabular}
		\caption{Variations sur \texttt{List.fold\_left} d'OCaml dans plusieurs dialectes de Core-ML.}
	\end{table}
\end{frame}

%============================================================

\begin{frame}{Types}
	\begin{mathpar}
	    \inferrule* 
	    	{ }
	    	{\V \subseteq \T}
	    \and
	    \inferrule*
	    	{ }
	    	{\unit \in \T}
	    \\
	    \inferrule*
	    	{\tau_1 \in \T \\ \tau_2 \in \T}
	    	{\tau_1 \times \tau_2 \in \T}
	    \and
	   	\inferrule*
	   		{\tau_1 \in \T \\ \tau_2 \in \T}
	   		{\tau_1 \rightarrow \tau_2 \in \T}
	   	\and
	    \inferrule*
	    	{f \in \F \\ \overline\tau \in \T^{|f|_\F}}
	    	{f (\overline\tau) \in \T}
	\end{mathpar}
	\begin{itemize}
		\item $\unit \rightarrow int \times float$ ;
		\item $int \rightarrow (int \rightarrow \alpha) \rightarrow array (\alpha)$ ;
		\item $(\alpha \rightarrow \beta \rightarrow \alpha) \rightarrow \alpha \rightarrow list (\beta) \rightarrow \alpha$.
	\end{itemize}
\end{frame}

%============================================================

\begin{frame}{Substitution de types}
	\begin{align*}
			\hat\sigma (\alpha) &=
			\sigma (\alpha)
		\\
			\hat\sigma (\unit) &=
			\unit
		\\
			\hat\sigma (\tau_1 \times \tau_2) &=
			\hat\sigma (\tau_1) \times \hat\sigma (\tau_2)
		\\
			\hat\sigma (\tau_1 \rightarrow \tau_2) &=
			\hat\sigma (\tau_1) \rightarrow \hat\sigma (\tau_2)
		\\
			\hat\sigma (f (\tau_1, \dots, \tau_{|f|_\F})) &=
			f (\hat\sigma (\tau_1), \dots, \hat\sigma (\tau_{|f|_\F}))
	\end{align*}
	TODO: exemples
\end{frame}

%============================================================

\begin{frame}{Théorie équationnelle, $\E$-équivalence}
	\small
	\begin{mathpar}
		\inferrule*
			[right = ($\equiv_\T^\E$-ax)]
			{\tau_1 \cong_\T \tau_2 \in \E}
			{\hat\sigma (\tau_1) \equiv_\T^\E \hat\sigma (\tau_2)}
		\and
		\inferrule*
			[right = ($\equiv_\T^\E$-refl)]
			{ }
			{\tau \equiv_\T^\E \tau}
		\\
		\inferrule*
			[right = ($\equiv_\T^\E$-trans)]
			{\tau_1 \equiv_\T^\E \tau_2 \\ \tau_2 \equiv_\T^\E \tau_3}
			{\tau_1 \equiv_\T^\E \tau_3}
		\and
		\inferrule*
			[right = ($\equiv_\T^\E$-sym)]
			{\tau_1 \equiv_\T^\E \tau_2}
			{\tau_2 \equiv_\T^\E \tau_1}
		\\
		\inferrule*
			[right = ($\equiv_\T^\E$-$\times_1$)]
			{\tau_1 \equiv_\T^\E \tau_1'}
			{\tau_1 \times \tau_2 \equiv_\T^\E \tau_1' \times \tau_2}
		\and
		\inferrule*
			[right = ($\equiv_\T^\E$-$\times_2$)]
			{\tau_2 \equiv_\T^\E \tau_2'}
			{\tau_1 \times \tau_2 \equiv_\T^\E \tau_1 \times \tau_2'}
		\\
		\inferrule*
			[right = ($\equiv_\T^\E$-$\rightarrow_1$)]
			{\tau_1 \equiv_\T^\E \tau_1'}
			{\tau_1 \rightarrow \tau_2 \equiv_\T^\E \tau_1' \rightarrow \tau_2}
		\and
		\inferrule*
			[right = ($\equiv_\T^\E$-$\rightarrow_2$)]
			{\tau_2 \equiv_\T^\E \tau_2'}
			{\tau_1 \rightarrow \tau_2 \equiv_\T^\E \tau_1 \rightarrow \tau_2'}
		\\
		\inferrule*
			[right = ($\equiv_\T^\E$-$\F$)]
			{f \in \F \\ i \in \interval 1 {|f|_\F} \\ \tau_i \equiv_\T^\E \tau_i'}
			{f (\tau_1, \dots, \tau_i, \dots, \tau_{|f|_\F}) \equiv_\T^\E f (\tau_1, \dots, \tau_i', \dots, \tau_{|f|_\F})}
	\end{mathpar}
\end{frame}

%============================================================

\begin{frame}{$\E$-unificateur}
	Une substitution $\sigma$ est un $\E$-unificateur des types $\tau_1$ et $\tau_2$ \ssi :
	\[ \hat\sigma (\tau_1) \equiv_\T^\E \hat\sigma (\tau_2) \]
	TODO: exemples
\end{frame}

%============================================================

\begin{frame}{Isomorphisme de types dans $\Lambda^1$}
	Deux types $\tau_1$ et $\tau_2$ sont isomorphes dans $\Lambda^1$ \ssi il existe deux $\lambda$-termes $f : \tau_1 \rightarrow \tau_2$ et $g : \tau_2 \rightarrow \tau_1$ tels que $f \circ g =_{\Lambda^1} \mathrm{id}_{\tau_2}$ et $g \circ f =_{\Lambda^1} \mathrm{id}_{\tau_1}$.
	TODO: exemples
\end{frame}

%============================================================

\begin{frame}{Théorie équationnelle $\E^1$}
	\begin{align}
			\alpha \times \beta &\cong_\T
			\beta \times \alpha
			\label{prod_comm}
			\tag{$\times$-comm}
		\\
			\alpha \times (\beta \times \gamma) &\cong_\T
			(\alpha \times \beta) \times \gamma
			\label{prod_assoc}
			\tag{$\times$-assoc}
		\\
			\unit \times \alpha &\cong_\T
			\alpha
			\label{prod_unit}
			\tag{$\times$-$\unit$}
		\\
			(\alpha \times \beta) \rightarrow \gamma &\cong_\T
			\alpha \rightarrow (\beta \rightarrow \gamma)
			\label{curry}
			\tag{curry}
		\\
			\unit \rightarrow \alpha &\cong_\T
			\alpha
			\label{curry_unit}
			\tag{curry-$\unit$}
		\\
			\alpha \rightarrow (\beta \times \gamma) &\cong_\T
			(\alpha \rightarrow \beta) \times (\alpha \rightarrow \gamma)
			\label{dist}
			\tag{dist}
		\\
			\alpha \rightarrow \unit &\cong_\T
			\unit
			\label{dist_unit}
			\tag{dist-$\unit$}
	\end{align}
\end{frame}

%============================================================

\begin{frame}{Théorie équationnelle $\E$}
	\begin{align}
			\alpha \times \beta &\cong_\T
			\beta \times \alpha
			\label{prod_comm}
			\tag{$\times$-comm}
		\\
			\alpha \times (\beta \times \gamma) &\cong_\T
			(\alpha \times \beta) \times \gamma
			\label{prod_assoc}
			\tag{$\times$-assoc}
		\\
			\unit \times \alpha &\cong_\T
			\alpha
			\label{prod_unit}
			\tag{$\times$-$\unit$}
		\\
			(\alpha \times \beta) \rightarrow \gamma &\cong_\T
			\alpha \rightarrow (\beta \rightarrow \gamma)
			\label{curry}
			\tag{curry}
	\end{align}
	\begin{itemize}
		\item $int \rightarrow float \rightarrow int \sim_\T float \rightarrow \alpha$ avec $\{ \alpha \mapsto int \rightarrow int \}$ ;
		\item $int \rightarrow \alpha \rightarrow \unit \sim_\T int \rightarrow \unit$ avec $\{ \alpha \mapsto \unit \}$ ;
		\item $int \rightarrow \alpha \rightarrow \unit \sim_\T int \rightarrow int \rightarrow int \rightarrow \unit$ avec $\{ \alpha \mapsto int \times int \}$ ;
		\item $(\alpha \rightarrow \beta \rightarrow \alpha) \rightarrow \alpha \rightarrow list (\beta) \rightarrow \alpha \sim_\T list (\gamma) \times \delta \rightarrow (\gamma \times \delta \rightarrow \delta) \rightarrow \delta$ \\ avec $\{ \gamma \mapsto \beta, \delta \mapsto \alpha \}$.
	\end{itemize}
\end{frame}

%============================================================

\begin{frame}{Substitution de types bien formée}
	Une substitution de types $\sigma$ est bien formée, noté $\sigma\ \bold{bf}$, \ssi :
	\[ \forall \alpha \in \V,\ \sigma (\alpha) \neq \unit \]
	TODO: exemples
\end{frame}

%============================================================

\begin{frame}{Unification syntaxique}
	\small
	\begin{mathpar}
		\inferrule*
			[right = (effacer)]
			{}
			{P \cup \{ \tau \qeq \tau \} \rightsquigarrow P}
		\\
		\inferrule*
			[right = (orienter)]
			{\tau \notin \V}
			{P \cup \{ \tau \qeq \alpha \} \rightsquigarrow P \cup \{ \alpha \qeq \tau \}}
		\\
		\inferrule*
			[right = (décomposer-$\times$)]
			{}
			{P \cup \{ \tau_1 \times \tau_2 \qeq \tau_1' \times \tau_2' \} \rightsquigarrow P \cup \{ \tau_1 \qeq \tau_1', \tau_2 \qeq \tau_2' \}}
		\\
		\inferrule*
			[right = (décomposer-$\rightarrow$)]
			{}
			{P \cup \{ \tau_1 \rightarrow \tau_2 \qeq \tau_1' \rightarrow \tau_2' \} \rightsquigarrow P \cup \{ \tau_1 \qeq \tau_1', \tau_2 \qeq \tau_2' \}}
		\\
		\inferrule*
			[right = (décomposer-$\F$)]
			{}
			{P \cup \{ f (\tau_1, \dots, \tau_{|f|_\F}) \qeq f (\tau_1', \dots, \tau_{|f|_\F}') \} \rightsquigarrow \\ P \cup \{ \tau_1 \qeq \tau_1', \dots, \tau_{|f|_\F} \qeq \tau_{|f|_\F}' \}}
		\\
		\inferrule*
			[right = (substituer)]
			{\alpha \in \mathrm{vars} (P) \\ \alpha \notin \mathrm{vars} (\tau)}
			{P \cup \{ \alpha \qeq \tau \} \rightsquigarrow \{ \alpha \mapsto \tau \} (P) \cup \{ \alpha \qeq \tau \}}
	\end{mathpar}
\end{frame}

%============================================================

\begin{frame}{Unification syntaxique — exemple}
	\begin{align}
			\{ int \rightarrow list (\alpha) \rightarrow \beta \qeq \gamma \rightarrow \delta \rightarrow \gamma \} &\rightsquigarrow
			\tag{decomposer-$\rightarrow$}
		\\
			\{ int \qeq \gamma, list (\alpha) \rightarrow \beta \qeq \delta \rightarrow \gamma \} &\rightsquigarrow
			\tag{orienter}
		\\
			\{ \gamma \qeq int, list (\alpha) \rightarrow \beta \qeq \delta \rightarrow \gamma \} &\rightsquigarrow
			\tag{substituer}
		\\
			\{ \gamma \qeq int, list (\alpha) \rightarrow \beta \qeq \delta \rightarrow int \} &\rightsquigarrow
			\tag{décomposer-$\rightarrow$}
		\\
			\{ \gamma \qeq int, list (\alpha) \qeq \delta, \beta \qeq int \} &\rightsquigarrow
			\tag{orienter}
		\\
			\{ \gamma \qeq int, \delta \qeq list (\alpha), \beta \qeq int \}
			\tag*{en forme résolue}
	\end{align}
\end{frame}

%============================================================

\begin{frame}{Types normalisés}
	\begin{mathpar}
	    \inferrule* 
	    	{ }
	    	{\V \subseteq \N}
	    \and
	    \inferrule*
	    	{ }
	    	{\N^\# \subseteq \N}
	    \\
	    \inferrule*
	    	{\nu^\# \in \N^\# \\ \nu \in \N}
	    	{\nu^\# \rightarrow \nu \in \N}
	    \and
	    \inferrule*
	    	{f \in \F \\ \overline\nu \in \N^{|f|_\F}}
	    	{f (\overline\nu) \in \N}
	\end{mathpar}
	\begin{itemize}
		\item $\mset{int, \mset{}, \alpha}$ ;
		\item $\mset{} \rightarrow \mset{} \rightarrow \mset{}$ ;
		\item $\mset{list (\mset{\alpha, int})} \rightarrow \mset{\alpha, \beta}$.
	\end{itemize}
\end{frame}

%============================================================

\begin{frame}{Genre d'un type normalisé}
	\begin{mathpar}
		\inferrule*
			{ }
			{\bold{var} \in \G}
		\and
		\inferrule*
			{ }
			{\bold{uplet} \in \G}
		\and
		\inferrule*
			{ }
			{\bold{fleche} \in \G}
		\and
		\inferrule*
			{f \in \F}
			{\bold{cons}_f \in \G}
	\end{mathpar}
	\begin{align*}
			[ \alpha ] &= \bold{var}
		\\
			[ \mset{\nu_1, \dots, \nu_n} ] &= \bold{uplet}
		\\
			[ \nu^\# \rightarrow \nu ] &= \bold{fleche}
		\\
			[ f (\overline \nu) ] &= \bold{cons}_f
	\end{align*}
\end{frame}

\begin{frame}{Type normalisé bien formé}
	\footnotesize
	\begin{mathpar}
		\inferrule*
			{ }
			{\alpha\ \bold{bf}}
		\and
		\inferrule*
			{\nu^\#\ \bold{pbf} \\ | \nu^\# |^\#_\N \neq 1}
			{\nu^\#\ \bold{bf}}
		\\
		\inferrule*
			{\nu^\#\ \bold{pbf} \\ \nu\ \bold{bf} \\ [\nu] \neq \bold{fleche}}
			{\nu^\# \rightarrow \nu\ \bold{bf}}
		\and
		\inferrule*
			{f \in \F \\ \forall i \in \interval 1 {|f|_\F},\ \nu_i\ \bold{bf}}
			{f (\nu_1, \dots, \nu_{|f|_\F})\ \bold{bf}}
		\\
		\inferrule*
			{ }
			{\alpha\ \bold{pbf}}
		\and
		\inferrule*
			{\forall i \in \interval 1 n,\ \nu_i\ \bold{bf} \wedge [\nu_i] \neq \bold{tuple}}
			{\mset{\nu_1, \dots, \nu_n}\ \bold{pbf}}
		\\
		\inferrule*
			{\nu^\#\ \bold{pbf} \\ \nu\ \bold{bf} \\ [\nu] \neq \bold{fleche}}
			{\nu^\# \rightarrow \nu\ \bold{pbf}}
		\and
		\inferrule*
			{f \in \F \\ \forall i \in \interval 1 {|f|_\F},\ \nu_i\ \bold{bf}}
			{f (\nu_1, \dots, \nu_{|f|_\F})\ \bold{pbf}}
	\end{mathpar}
\end{frame}

%============================================================

\end{document}





























